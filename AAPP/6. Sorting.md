# Divide and conquer for sorting
![[Pasted image 20231003143133.png]]
quick sort is a divide and conquer approach, combine is trivial, we do not to do anything.
is important to divide the part in a good way...the divide part has to be of the lowest complexity as possible,  linear. if we have linear divide part the algo will be very efficient.

![[Pasted image 20231003143331.png]]
the algo work on the same array, but in diffrent partition. 
... explanation of the pseudo code is done so understand it!
Recurrence formula:
![[Pasted image 20231003144427.png]]
![[Pasted image 20231003144445.png]]


Recurrence formula:
![[Pasted image 20231003145110.png]]
![[Pasted image 20231003145126.png]]
![[Pasted image 20231003145137.png]]
Is there a way that make me sure that in general we have the lucky case? we can introduce the randomization in order to pick the pivot at random: since the pivot is chosen at random, it is very unlikely that we chose a pivot in a way that one of the 2 part of the array that are generated is empty.
![[Pasted image 20231003145739.png]]
![[Pasted image 20231003150208.png]]



define t(n) as a set of possible recursion.  such all of them has the same probability we can calculate t(n) as the summation of all them
seguono un sacco di calcoli che non capisco
![[Pasted image 20231003150228.png]]
![[Pasted image 20231003150426.png]]
![[Pasted image 20231003150503.png]]
altre slide con calcoli che non capisco...


riprendo da qui slide 49 sort
![[Pasted image 20231003150631.png]]


# Best complexity for sorting
